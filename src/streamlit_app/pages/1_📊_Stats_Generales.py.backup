"""
Page: Statistiques G√©n√©ralewith st.sidebar:
    # √âmoji ajout√© via HTML pour √©viter les probl√®mes d'encodage
    st.markdown('<h3>üìÇ S√©lection d\'√©dition</h3>', unsafe_allow_html=True)
    
    multi_manager = MultiEditionManager()ffiche les statistiques par ELO, r√¥le, et classement des √©quipes
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from pathlib import Path
import sys

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from src.core.data_manager import EditionDataManager, MultiEditionManager

st.set_page_config(page_title="Stats G√©n√©rales - OcciLan Stats", page_icon="üìä", layout="wide")

# Custom CSS pour masquer la navigation par d√©faut
st.markdown("""
<style>
    [data-testid="stSidebarNav"] {
        display: none;
    }
</style>
""", unsafe_allow_html=True)

# ============================================================================
# SIDEBAR - Navigation coh√©rente
# ============================================================================

with st.sidebar:
    st.markdown("### ÔøΩ S√©lection d'√©dition")
    
    multi_manager = MultiEditionManager()
    
    # V√©rifier si l'utilisateur est admin
    is_admin = st.session_state.get("authenticated", False)
    
    # Lister les √©ditions (priv√©es uniquement si admin)
    available_editions = multi_manager.list_editions(include_private=is_admin)
    
    if not available_editions:
        st.warning("‚ö†Ô∏è Aucune √©dition disponible")
        st.info("üí° Cr√©ez une √©dition dans la page Admin")
        selected_edition = None
    else:
        selected_edition = st.selectbox(
            "√âdition",
            available_editions,
            format_func=lambda x: f"Edition {x}",
            label_visibility="collapsed"
        )
        
        if selected_edition:
            edition_manager = EditionDataManager(selected_edition)
            config = edition_manager.load_config()
            
            if config:
                st.markdown(f"**{config.get('name', 'N/A')}**")
                st.caption(f"üìÜ {config.get('start_date', 'N/A')} ‚Üí {config.get('end_date', 'N/A')}")
    
    st.markdown("---")
    st.markdown("### üß≠ Navigation")
    st.page_link("app.py", label="üè† Accueil")
    st.page_link("pages/1_üìä_Stats_Generales.py", label="üìä Stats G√©n√©rales")
    st.page_link("pages/9_üîß_Admin.py", label="üîß Admin")
    st.markdown("---")
    st.caption("üéÆ OcciLan Stats v2.0")

# ============================================================================
# CONFIGURATION
# ============================================================================

st.title("üìä Statistiques G√©n√©rales")

if not available_editions or not selected_edition:
    st.stop()

edition_manager = EditionDataManager(selected_edition)

# ============================================================================
# LOAD DATA
# ============================================================================

teams_with_puuid = edition_manager.load_teams_with_puuid()

if not teams_with_puuid:
    st.info("‚ÑπÔ∏è Aucune donn√©e disponible pour cette √©dition. Veuillez d'abord ex√©cuter le pipeline (√©tapes 2-3).")
    st.stop()

# ============================================================================
# CALCUL DES STATISTIQUES
# ============================================================================

# Mapping des ELO vers des scores num√©riques
ELO_SCORES = {
    "IRON": 1,
    "BRONZE": 2,
    "SILVER": 3,
    "GOLD": 4,
    "PLATINUM": 5,
    "EMERALD": 6,
    "DIAMOND": 7,
    "MASTER": 8,
    "GRANDMASTER": 15,
    "CHALLENGER": 20
}

# Mapping des divisions
DIVISION_MULTIPLIERS = {
    "I": 0.75,
    "II": 0.5,
    "III": 0.25,
    "IV": 0.0
}

def calculate_player_score(tier: str, rank: str, lp: int) -> float:
    """Calcule le score d'un joueur bas√© sur son ELO"""
    base_score = ELO_SCORES.get(tier, 0)
    
    # Master+ : +1 par 100 LP
    if tier in ["MASTER", "GRANDMASTER", "CHALLENGER"]:
        return base_score + (lp / 100.0)
    
    # Autres: score de base + bonus de division
    division_bonus = DIVISION_MULTIPLIERS.get(rank, 0)
    return base_score + division_bonus

# Collecter tous les joueurs
all_players = []
team_scores = {}

for team_name, team_data in teams_with_puuid.items():
    players = team_data.get("players", [])
    team_total_score = 0
    team_player_count = 0
    
    for player in players:
        tier = player.get("tier", "UNRANKED")
        rank = player.get("rank", "IV")
        lp = player.get("leaguePoints", 0)
        role = player.get("role", "UNKNOWN")
        
        # Calculer le score
        score = calculate_player_score(tier, rank, lp)
        
        all_players.append({
            "team": team_name,
            "gameName": player.get("gameName", "Unknown"),
            "tagLine": player.get("tagLine", "0000"),
            "role": role,
            "tier": tier,
            "rank": rank,
            "lp": lp,
            "score": score,
            "summonerLevel": player.get("summonerLevel", 0)
        })
        
        if tier != "UNRANKED":
            team_total_score += score
            team_player_count += 1
    
    # Moyenne de l'√©quipe
    if team_player_count > 0:
        team_scores[team_name] = {
            "avg_score": team_total_score / team_player_count,
            "player_count": team_player_count
        }

df_players = pd.DataFrame(all_players)
total_players = len(df_players)

# ============================================================================
# M√âTRIQUES G√âN√âRALES
# ============================================================================

st.header("üìà Vue d'ensemble")

col1, col2, col3, col4 = st.columns(4)

with col1:
    st.metric("üë• Joueurs", total_players)

with col2:
    st.metric("üèÜ √âquipes", len(teams_with_puuid))

with col3:
    ranked_players = len(df_players[df_players["tier"] != "UNRANKED"])
    st.metric("üéÆ Class√©s", ranked_players)

with col4:
    if ranked_players > 0:
        avg_score = df_players[df_players["tier"] != "UNRANKED"]["score"].mean()
        st.metric("üìä Score moyen", f"{avg_score:.2f}")
    else:
        st.metric("üìä Score moyen", "N/A")

# ============================================================================
# R√âPARTITION PAR R√îLE ET ELO
# ============================================================================

st.header("üéØ R√©partition par r√¥le et √âlo")

# Cr√©er le tableau de r√©partition
role_order = ["TOP", "JGL", "MID", "ADC", "SUP"]
elo_order = ["BRONZE", "SILVER", "GOLD", "PLATINUM", "EMERALD", "DIAMOND", "MASTER", "GRANDMASTER", "CHALLENGER", "UNRANKED"]

# Filtrer les joueurs class√©s
df_ranked = df_players[df_players["tier"] != "UNRANKED"]

if len(df_ranked) > 0:
    # Cr√©er le pivot table
    pivot = pd.crosstab(
        df_ranked["tier"],
        df_ranked["role"],
        margins=True,
        margins_name="Total"
    )
    
    # R√©organiser les colonnes selon l'ordre des r√¥les
    cols_ordered = [col for col in role_order if col in pivot.columns] + ["Total"]
    pivot = pivot[cols_ordered]
    
    # R√©organiser les lignes selon l'ordre des ELO
    rows_ordered = [row for row in elo_order if row in pivot.index and row != "UNRANKED"]
    if "Total" in pivot.index:
        rows_ordered.append("Total")
    pivot = pivot.loc[rows_ordered]
    
    # Renommer les colonnes pour l'affichage
    pivot.columns = ["Top", "Jungle", "Mid", "Adc", "Supp", "Total"]
    
    # Couleurs par tier
    tier_colors = {
        "CHALLENGER": "#FCA5A5",
        "GRANDMASTER": "#FCA5A5",
        "MASTER": "#C4B5FD",
        "DIAMOND": "#93C5FD",
        "EMERALD": "#86EFAC",
        "PLATINUM": "#67E8F9",
        "GOLD": "#FCD34D",
        "SILVER": "#D1D5DB",
        "BRONZE": "#FDBA74",
        "Total": "#374151"
    }
    
    # Cr√©er le HTML du tableau manuellement
    html_table = """
    <style>
        .custom-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'Source Sans Pro', sans-serif;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        .custom-table th {
            background-color: #1F2937;
            color: white;
            font-weight: bold;
            padding: 12px;
            text-align: center;
            border: 1px solid #111827;
        }
        .custom-table td {
            padding: 10px;
            text-align: center;
            border: 1px solid #374151;
            font-size: 14px;
        }
        .custom-table .tier-cell {
            font-weight: bold;
            color: #1F2937;
        }
        .custom-table .total-row {
            background-color: #374151;
            color: white;
            font-weight: bold;
        }
        .custom-table .total-col {
            background-color: #4B5563;
            color: white;
            font-weight: bold;
        }
    </style>
    <table class="custom-table">
        <thead>
            <tr>
                <th>tier</th>
                <th>Top</th>
                <th>Jungle</th>
                <th>Mid</th>
                <th>Adc</th>
                <th>Supp</th>
                <th>Total</th>
            </tr>
        </thead>
        <tbody>
    """
    
    # Ajouter les lignes de donn√©es
    for tier_name in pivot.index:
        row = pivot.loc[tier_name]
        bg_color = tier_colors.get(tier_name, "#262730")
        
        if tier_name == "Total":
            html_table += f'<tr class="total-row">'
            html_table += f'<td>{tier_name}</td>'
        else:
            html_table += f'<tr>'
            html_table += f'<td class="tier-cell" style="background-color: {bg_color};">{tier_name}</td>'
        
        # Ajouter les colonnes de valeurs
        for idx, col_name in enumerate(pivot.columns):
            value = row[col_name]
            if tier_name == "Total":
                html_table += f'<td>{value}</td>'
            elif col_name == "Total":
                html_table += f'<td class="total-col">{value}</td>'
            else:
                html_table += f'<td>{value}</td>'
        
        html_table += '</tr>'
    
    html_table += """
        </tbody>
    </table>
    """
    
    # Afficher le tableau HTML
    st.markdown(html_table, unsafe_allow_html=True)
    
    # ============================================================================
    # GRAPHIQUES
    # ============================================================================
    
    st.subheader("üìä Graphiques de r√©partition")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # Graphique: R√©partition des r√¥les par ELO (stacked bar)
        # Couleurs adapt√©es aux ELO
        elo_colors = {
            "GRANDMASTER": "#FF6B6B",
            "MASTER": "#A855F7",
            "DIAMOND": "#3B82F6",
            "EMERALD": "#10B981",
            "PLATINUM": "#06B6D4",
            "GOLD": "#F59E0B",
            "SILVER": "#9CA3AF",
            "BRONZE": "#CD7F32",
            "IRON": "#78716C"
        }
        
        fig1 = px.bar(
            df_ranked,
            x="tier",
            color="role",
            category_orders={
                "tier": [t for t in elo_order if t in df_ranked["tier"].unique()],
                "role": role_order
            },
            color_discrete_map={
                "TOP": "#FF6B6B",
                "JGL": "#4ECDC4",
                "MID": "#FFE66D",
                "ADC": "#95E1D3",
                "SUP": "#C7CEEA"
            },
            title="R√©partition des r√¥les par √âlo",
            labels={"tier": "√âlo", "count": "Nombre", "role": "R√¥le"}
        )
        fig1.update_layout(
            xaxis_title="√âlo",
            yaxis_title="Nombre de joueurs",
            legend_title="R√¥le",
            height=500
        )
        st.plotly_chart(fig1, use_container_width=True)
    
    with col2:
        # Graphique: Total par ELO avec couleurs adapt√©es
        elo_counts = df_ranked["tier"].value_counts().reindex(
            [t for t in elo_order if t in df_ranked["tier"].unique()]
        )
        
        # Couleurs pour chaque ELO (pastel)
        elo_color_map = {
            "GRANDMASTER": "#FCA5A5",  # Rose pastel
            "MASTER": "#C4B5FD",        # Violet pastel
            "DIAMOND": "#93C5FD",        # Bleu pastel
            "EMERALD": "#86EFAC",        # Vert pastel
            "PLATINUM": "#67E8F9",       # Cyan pastel
            "GOLD": "#FCD34D",           # Jaune pastel
            "SILVER": "#D1D5DB",         # Gris pastel
            "BRONZE": "#FDBA74",         # Orange pastel
            "IRON": "#A8A29E"            # Gris-brun pastel
        }
        
        colors = [elo_color_map.get(elo, "#667BC6") for elo in elo_counts.index]
        
        fig2 = go.Figure()
        
        # Bar chart avec couleurs par ELO
        fig2.add_trace(go.Bar(
            x=elo_counts.index,
            y=elo_counts.values,
            name="Total",
            marker_color=colors,
            showlegend=False
        ))
        
        # Line chart (tendance)
        fig2.add_trace(go.Scatter(
            x=elo_counts.index,
            y=elo_counts.values,
            mode="lines+markers",
            name="Tendance",
            line=dict(color="#DC2626", width=4),  # Rouge plus visible
            marker=dict(size=12, color="#DC2626", line=dict(width=2, color="white"))
        ))
        
        fig2.update_layout(
            title="Total par √âlo (nombre de joueurs)",
            xaxis_title="√âlo",
            yaxis_title="Total",
            height=500,
            showlegend=True
        )
        
        st.plotly_chart(fig2, use_container_width=True)

else:
    st.info("‚ÑπÔ∏è Aucun joueur class√© trouv√©")

# ============================================================================
# SEEDING / CLASSEMENT DES √âQUIPES
# ============================================================================

st.header("üèÖ Seeding / Classement des √©quipes")

if team_scores:
    # Cr√©er le DataFrame de classement
    ranking_data = []
    for team_name, data in team_scores.items():
        avg_score = data["avg_score"]
        
        # D√©terminer le tier estim√©
        if avg_score >= 15:
            estimated_tier = "Grandmaster"
        elif avg_score >= 8:
            estimated_tier = "Master"
        elif avg_score >= 7:
            estimated_tier = "Diamond"
        elif avg_score >= 6:
            estimated_tier = "Emerald"
        elif avg_score >= 5:
            estimated_tier = "Platinum"
        elif avg_score >= 4:
            estimated_tier = "Gold"
        elif avg_score >= 3:
            estimated_tier = "Silver"
        elif avg_score >= 2:
            estimated_tier = "Bronze"
        else:
            estimated_tier = "Iron"
        
        ranking_data.append({
            "Team": team_name,
            "Avg Score": avg_score,
            "Estimated Tier": estimated_tier
        })
    
    df_ranking = pd.DataFrame(ranking_data)
    df_ranking = df_ranking.sort_values("Avg Score", ascending=False).reset_index(drop=True)
    df_ranking.index = df_ranking.index + 1
    df_ranking.index.name = "Rank"
    
    # Afficher le tableau
    st.dataframe(
        df_ranking,
        use_container_width=True
    )
    
    # Explication
    with st.expander("‚ÑπÔ∏è Explication du syst√®me de scoring"):
        st.markdown("""
        **Syst√®me de calcul:**
        
        | Tier | Score de base | Bonus |
        |------|---------------|-------|
        | Iron | 1 | - |
        | Bronze | 2 | - |
        | Silver | 3 | - |
        | Gold | 4 | - |
        | Platinum | 5 | +0.75 (I), +0.5 (II), +0.25 (III), +0 (IV) |
        | Emerald | 6 | +0.75 (I), +0.5 (II), +0.25 (III), +0 (IV) |
        | Diamond | 7 | +0.75 (I), +0.5 (II), +0.25 (III), +0 (IV) |
        | Master | 8 | +1 par 100 LP |
        | Grandmaster | 15 | +1 par 100 LP |
        | Challenger | 20 | +1 par 100 LP |
        
        **Le score de l'√©quipe** est la moyenne des scores individuels de ses joueurs.
        
        **Le Rank** (1 = meilleur seed) est d√©termin√© par ordre d√©croissant du score moyen.
        """)

else:
    st.info("‚ÑπÔ∏è Aucune √©quipe avec joueurs class√©s")

# ============================================================================
# D√âTAILS PAR √âQUIPE
# ============================================================================

st.header("üë• D√©tails par √©quipe")

selected_team = st.selectbox(
    "S√©lectionner une √©quipe",
    sorted(teams_with_puuid.keys())
)

if selected_team:
    team_players = df_players[df_players["team"] == selected_team]
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        # Tri par r√¥le
        role_order_dict = {role: i for i, role in enumerate(role_order)}
        team_players["role_order"] = team_players["role"].map(lambda x: role_order_dict.get(x, 99))
        team_players_sorted = team_players.sort_values("role_order")
        
        # Afficher les joueurs
        st.subheader(f"Composition de {selected_team}")
        
        for _, player in team_players_sorted.iterrows():
            tier_display = f"{player['tier']} {player['rank']}" if player['tier'] != "UNRANKED" else "UNRANKED"
            lp_display = f" ({player['lp']} LP)" if player['tier'] in ["MASTER", "GRANDMASTER", "CHALLENGER"] else ""
            
            st.markdown(f"""
            **{player['role']}** - `{player['gameName']}#{player['tagLine']}`  
            üéØ {tier_display}{lp_display} | üìä Score: {player['score']:.2f} | Level {player['summonerLevel']}
            """)
    
    with col2:
        # Stats de l'√©quipe
        st.subheader("üìä Statistiques")
        
        ranked_in_team = team_players[team_players["tier"] != "UNRANKED"]
        
        if len(ranked_in_team) > 0:
            avg_score = ranked_in_team["score"].mean()
            max_score = ranked_in_team["score"].max()
            min_score = ranked_in_team["score"].min()
            
            st.metric("Score moyen", f"{avg_score:.2f}")
            st.metric("Meilleur score", f"{max_score:.2f}")
            st.metric("Score min", f"{min_score:.2f}")
            
            # R√©partition des ELO dans l'√©quipe avec couleurs pastel
            elo_color_map_pastel = {
                "GRANDMASTER": "#FCA5A5",
                "MASTER": "#C4B5FD",
                "DIAMOND": "#93C5FD",
                "EMERALD": "#86EFAC",
                "PLATINUM": "#67E8F9",
                "GOLD": "#FCD34D",
                "SILVER": "#D1D5DB",
                "BRONZE": "#FDBA74",
                "IRON": "#A8A29E"
            }
            
            fig_team_elo = px.pie(
                ranked_in_team,
                names="tier",
                title="R√©partition des ELO",
                hole=0.4,
                color="tier",
                color_discrete_map=elo_color_map_pastel
            )
            st.plotly_chart(fig_team_elo, use_container_width=True)
        else:
            st.info("Aucun joueur class√© dans cette √©quipe")
